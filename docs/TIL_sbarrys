[ 다형성의 본질 ]
- 역할과 구현을 분리하는것이다.
 ex)  MemberService(클라) -> MemberRepository.save()
                               ㄴ MemoryMemberRepository.save() // override
                               ㄴ JDBCMemberRepository.save() // override

        MemberService -> MemoryMemberRepository.save() 사용 가능
        MemberService -> JDBCMemberRepository.save() 사용 가능

- 즉, 실행 시점에서 유연하게 변경해서 원하는 것을 사용 할 수 있다.
- 클라이언트를 변경하지 않고 서버의 구현기능을 실행할때 원하는 기능으로 유연하게 변경 할 수있다.
- 실세계의 역할(로미오 역)과 구현(김태희, 전지현)을 구분해서  유연,변경용이,확장가능 하게 구현  => 역할이 바뀐다면 모든것을 뜯어고쳐야함
- 인터페이스(API, usb 인터페이스 등)의 안정적 설계가 중요


[스프링에서 다형성??]
스프링은 다형성을 극대화 해서 사용할 수 있게 해준다.
역할과 구현을 구분해서  원하는 시점에 변경해서 적절한 기능을 끼워서 이용할 수 있게 해주는것이다.
IOC /DI 는 다형성 ( 역할과 구현의 구분 ) 을 편리하게 할 수 있게 지원해주는 기능이다.
스프링을 이용하면 조립하듯이 개발 할 수있다.

[객체지향 구현 5원칙]
SOLID - 객체지향을 구현을 할 때 지켜야할 5가지 원칙이다
  > 한개의 클래스는 한개의 책임(기능)만 담당해야 한다.  ( M/V/C 분리 등등 )
  > 개방 폐쇄 원칙 ( 기능 추가 (확장) 할 때 수정하지 않고 가능해야한다. )
   ㄴ 다형성을 생각해서 역할과 구현을 생각해보자. 역할을 추가하는데, 구현에 대한 수정을 필요하지 않다.
   ㄴ 그런데, 생각해보자 - Service(클라) 에 있는 Repository 를 변경하려면 코드 수정이 필요하다. - 원칙이 깨지는 것
      그러면 어떻게해야할까? 우리는 그래서 연관관계를 맺어주는 설정자 가 필요해졌다.
      이렇게 DI 가 생기게 되고 우리는 클라이언트 코드를 수정하지 않고, 기능의 추가,변경이 가능해졌다.
  >
  > 인터페이스 분리 원칙 ( 각 클라이언트마다 다양한 인터페이스로 설계 해주어야 한다.)
  > 의존성 역전 원칙   - >  그래서 IOC 를 생기게 된다.

[ ctrl-alt-S ]
grade - build and Run 을 둘다 IntelliJ 로 바꾸기
인텔리제이에서 자바를 바로 실행해서 빠르다.

=======================================================================================
[역할과 구현체]
역할을 사용할때 구현체 생성자를 이용해서 생성해주지 않으면 NullPointExceiption이 뜬다.


[Junit Test]
        //given
        Member member = new Member(1L,"memberA", Grade.VIP);

        //when
        memberService.join(member);
        Member findMember = memberService.findMember(1L);

        //then
        Assertions.assertThat(member).isEqualTo(findMember);
=======================================================================================
[프레임워크와 라이브러리 차이]
IOC - 프레임워크
 @Test 를 예로 보자. 우리는 글자를 쓰고, 로직만 짯다. 하지만 우리가 쓴 코드들은 프레임워크가 제어권을 가져가서 실행해준다.
[DI]
의존관계 주입
 어떤 구현 객체가 사용될지 모른다. 그래서, 클라이언트 코드를 변경하지 않고, 클라이언트가 호출하는 대상의 객체인스턴스를 변경할 수 있다.
 정적인 클래스 의존관계를 건들지 않고 동적인 객체 인스턴스 의존관계를 수정할 수 있다.
 [IOC컨테이너 DI컨테이너]
 AppConfig 처럼 객체를 생성하고 의존관계를 연결해 주는것을 IOD,DI컨테이너라고 한다.
=======================================================================================

AppConfig 에 @Configuartion 붙이고
각 메소드에 @Bean 붙여주고

AppConfig 내부의 생성자들을 사용하는곳에서
        ApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class);
이렇게  AppConfig 클래스를 담고있는 applicationContext를 만든다면,
우리는 사용할 수 있다.




=======================================================================================
[싱글톤 패턴 ]
클래스 인스턴스가 클래스 생성시  static 영역에서 딱 1개만 생성되고, 이것들을 공유한다.
외부에서 생성자를 사용해서 new 할 수 없도록 private 로 생성자를 만들어준다.

@Configuration 을 붙여놓은 것들을 Bean으로 만들때 바이트 조작을 통해 상속받은 임의의 다른 클래스를 만들도록 하여
싱글톤을 유지한다.




=======================================================================================

[스프링은 빈 설정을 어떻게 도와주나?]
xml 을 이용한 bean설정이나
Java 의 @Bean 어노테이션을 이용한 bean 설정들은
빈들을 하나하나 설정해주어야했다.
스프링은 이것 들에서 진화해서
 설정 정보가 없어도 빈으로 자동 등록 해주는 컴포넌트 스캔이라는 기능
  + 자동으로 의존 관계를 주입시켜 주는 @Autowired 라는 어노테이션을 제공하게 된다.


